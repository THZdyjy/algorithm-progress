"""
场景：
动态规划是一种最优化方法，一般用来求最值。所以遇到求最值问题，一般都是用动态规划来解决，核心在于思考如何穷举所有可能得结果。
其核心是穷举，即在状态转移的过程中，遍历了所有的状态，并得到最大值或者最小值。
穷举这一过程，伴随着几个特点，比如肯定会存在重叠，这就是重叠子问题，可以用备忘录、dp table等来优化。
另外因为是一步一步穷举的，前面几步肯定为后面几步做了积累，即通过子问题的最值可以得到原问题的最值，因此存在最优子结构，其实就是思考如何写状态转移方程。

重叠子问题：
    如何一眼看出重叠子问题
    首先，最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点。
最优子结构：
   找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。
dp数组的大小设置：
    根据base情况的不同，初始化dp的大小也不同
dp遍历方向
    由状态转移方程来决定：1、遍历的过程中，所需的状态必须是已经计算出来的。2、遍历结束后，存储结果的那个位置必须已经被计算出来。

总结：
动态规划的三个核心：
    1，base case：终点也是起点，最简单的情况，最原始的，最基础的-》生死
    2，重叠子问题：用dp table来优化穷举过程 -》反思
    3，最优子结构与状态转移方程：通过子问题的值得到原问题的最值，然后列出正确的状态转移方程 -》外力、选择，促使人生状态的转变，状态的变化构成了整个人生

如何列状态转移方程：
    1，确定base case，即最简单的情况是什么
    2，确定状态，原问题和子问题中的变量（状态转移嘛，即变化，要发生变化的，即状态，即变量）
    3，选择，在当下状态，可以做出什么选择使得状态发生改变（状态转移，那促使状态发生变化的必然受到了外力，即出现了动机，条件，那条件是什么呢）
    4，定义dp数组/函数，来描述这种状态转移的过程；当前状态->选择->下一个状态 （明确目标，有目标，才有动力，才能发生状态转移）
    5，如若能进行状态压缩，则进行压缩。相当于把所有经验压缩到一个状态。后面的路只需看当下。有一种【大道至简】的感觉

    ###################################################################################################
    #明确目标-》选择（舍得）-》人生状态的改变，量变引起质变-》反思，踩坑，闭坑-》以终为始，终点即起点，死即是生，踏破生死轮回#
    ###################################################################################################
状态压缩：减小空间复杂度

在做题的过程中，去体会上述的思想是如何应用的，大道归一。体会阴阳变化。

模板： 这两种思维方式多多理解，前者更像
    # 自顶向下递归的动态规划
    def dp(状态1, 状态2, ...):
        for 选择 in 所有可能的选择:
            # 此时的状态已经因为做了选择而改变
            result = 求最值(result, dp(状态1, 状态2, ...))
        return result

    # 自底向上迭代的动态规划
    # 初始化 base case
    dp[0][0][...] = base case
    # 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

"""


