class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        n = len(prices)
        # 一共n天，每天有两种状态，持有/未持有股票
        dp = [[0] * 2 for _ in range(n)]
        # base_case
        for i in range(n):
            # base case
            if i == 0:
                dp[0][0] = 0
                dp[0][1] = -prices[i]
                continue

            # 今天未持有-> 昨天未持有/ 昨天持有，然后今天卖出
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            # 今天持有-> 昨天未持有，然后今天买入 / 昨天持有
            dp[i][1] = max(-prices[i], dp[i - 1][1])
        return dp[n - 1][0]

"""
这里交易次数为1，将1，带入状态转移方程：
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
简化为：
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
k都是1，继续简化
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], 0 - prices[i])

这里我们思考base case:
第0天的时候，如果未持有，说明没有买股票，此时
dp[0][0] = 0
如果持有，说明买了股票，此时
dp[0][1] = -prices[0]
"""


"""
core: 三种状态
天数：一共n天
允许买卖的最大次数k：k从0开始->K.可以理解为机会，一共K次机会。从0开始，1，2，k， 允许交易一次(已经交易1次，用了一次机会)，允许交易2次，允许交易k次.....
是否持有：未持有0/持有为1
直接给出状态转移方程：
    第i天，已进行k次交易（用了k次机会）,未持有股票
    dp[i][k][0] = max(
                        dp[i-1][k][0],               昨天未持有
                        dp[i-1][k][1] + prices[i]    昨天持有，但是今天卖出了,因此利润增加了
    )
    第i天，已进行k次交易（用了k次机会）,持有股票
    dp[i][k][1] = max(
                        dp[i-1][k-1][0] - prices[i], 昨天未持有，今天买入，利润减少,到昨天止用了k-1次机会，今天由于买入，用了k次机会
                        dp[i-1][k][1]                昨天持有，
    )
base case:
    dp[-1][...][0] = 0
    解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

    dp[-1][...][1] = -infinity
    解释：还没开始的时候，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

    dp[...][0][0] = 0
    解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

    dp[...][0][1] = -infinity
    解释：不允许交易的情况下，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
总结：
    base case：
    dp[-1][...][0] = dp[...][0][0] = 0
    dp[-1][...][1] = dp[...][0][1] = -infinity

    状态转移方程：
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])


"""
