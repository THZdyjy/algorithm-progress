def knapsack(W, N, wt, val):
    assert N == len(wt)
    # 初始化一个二维数组，用于存储状态
    # dp[i][j] 表示将前 i 个物品装入容量为 j 的背包中所获得的最大价值、
    #
    dp = [[0] * (W + 1) for _ in range(N + 1)]
    # 开始进行递推
    for i in range(1, N + 1):
        for w in range(1, W + 1):
            if w - wt[i - 1] < 0:
                # 当前商品 i 的重量已经超过了 w，无法被放入当前容量为 w 的背包中，只能选择不装入背包
                dp[i][w] = dp[i - 1][w]
            else:
                # 当前商品 i 的重量小于等于当前容量 w，可以尝试将其放入背包中
                # 取最大值，考虑是将其放入之前的最优方案中还是选择不放
                if dp[i - 1][w] > dp[i - 1][w - wt[i - 1]] + val[i - 1]:
                    x, y = dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]
                dp[i][w] = max(
                    dp[i - 1][w - wt[i - 1]] + val[i - 1],
                    dp[i - 1][w]
                )
    # 返回最大价值
    return dp[N][W]
print(knapsack(4, 3, [2, 1, 3], [4, 2, 3]))
"""
给定一个背包和几个物品，形成一个背包问题；
因此状态有两个①背包的容量 ②可选择的物品
因此用二维dp,对应dp[i][w]表示容量为w的背包，放入前i个物品所获得的最大价值、
因此最终的答案为dp[N][W]. base case 为 dp[0][...] = dp[...][0] = 0即没有物品可选&背包容量为0时候，价值为0
状态转移：
    不装入背包：        dp[i][w] = dp[i-1][w]
    把第i个物品装入背包： dp[i][w] = val[i-1] + dp[i-1][w-wt[i-1]] 
    第i个物品的价值 前i-1件商品的容量为w‘,又加了个物品，则现在的容量w如下 -> 则w' + wt[i-1] = w 所以 w’ = w - wt[i-1]
"""