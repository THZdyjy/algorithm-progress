
# 这个状态转移方程的确定：由base进行思考，直到base后，如何往下推一层，状态如何进行转移。
def longestPalindromeSubseq(s: str) -> int:
    n = len(s)
    # dp 数组全部初始化为 0
    dp = [[0] * n for _ in range(n)]
    # base case
    for i in range(n):
        dp[i][i] = 1
    # 反着遍历保证正确的状态转移
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            # 状态转移方程
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2 # 由中间到两边
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    # 整个 s 的最长回文子串长度
    return dp[0][n - 1]

    """
    core:base case: 当只有一个字母时，这个字母就是回文子序列，为1.
    我们逆着来对字母进行判断：
        对于abae, 定义dp[i][j]为字符串s[i:j]的最长回文子序列, 双闭区间，
        则二维dp的对角线为1，i==j嘛，左下角全为0. 因为i<=j嘛。
        然后我们逆着来，i=3，j=4 过； i=2，j=3； i=1，j=2，3； i=0，j=1，2，3
    
    为什么逆着判断呢，先看状态转移方程
    先看状态转移方程：
        这取决于 s[i] 和 s[j] 的字符， 想象由中心向两边的过程
        如果它俩相等，那么它俩加上 s[i+1..j-1] 中的最长回文子序列就是 s[i..j] 的最长回文子序列
        如果它俩不相等，说明它俩不可能同时出现在 s[i..j] 的最长回文子序列中，那么把它俩分别加入 s[i+1..j-1] 中，看看哪个子串产生的回文子序列更长即可：
        if (s[i] == s[j])
            // 它俩一定在最长回文子序列中
            dp[i][j] = dp[i + 1][j - 1] + 2;
        else
            // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
    
    为什么逆着判断呢
    看看刚才写的状态转移方程，想求 dp[i][j] 需要知道 dp[i+1][j-1]，dp[i+1][j]，dp[i][j-1] 这三个位置, 即左边，下边，左下角
    为了保证每次计算 dp[i][j]，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历：所以我们反着遍历
    最后返回dp[0][n-1] 即是s的最大回文子序列
    """
longestPalindromeSubseq('abae')