class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 1, 1
        while fast < len(nums):
            if nums[fast] != nums[slow-1]:
                nums[slow] = nums[fast]
                slow += 1
                fast += 1
            else:
                fast += 1
        return slow

"""
core: 双指针
i为慢指针，j为快指针。因为数组的第一个元素肯定是不重复的。初始化时让ij同时指向index==1
判断当前值是否和前一值相等？若是，说明当前值是重复元素，i不动（维护这个重复元素的位置），
j+1, 向前去探索新的非重复元素。
当找到时，即当前元素不是重复元素时，那么将j位置元素放到i位置，
这时i向前移动1位，这时它仍然维护的是重复元素的位置 （可以分为两种情况讨论，j与i挨着，赋值后，j位置的元素就变成两个了，依旧是重复的；j与i不挨着，说明i后面的位置元素是重复的。其实一句话可以说明白：j始终维护的是非重复元素位置，所以他前面的肯定是重复的）
[0,0,1,2,3,4,3,5] 这个就是错误的，注意原题目是有序的

core2: 更为本质的思路是，保留k位。
「通用解法」是一种针对「数据有序，相同元素最多保留 k 位」问题更加本质的解法，
该解法是从性质出发提炼的，利用了「数组有序 & 保留逻辑」两大主要性质。建议重点掌握 ~
"""